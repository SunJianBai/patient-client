# 客户端通过长度前缀接收JSON的完整实现

## 完整的客户端接收类

```cpp
// jsonclient.h
#ifndef JSONCLIENT_H
#define JSONCLIENT_H

#include <QTcpSocket>
#include <QJsonDocument>
#include <QObject>
#include <QTimer>

class JsonClient : public QObject
{
    Q_OBJECT
public:
    explicit JsonClient(QObject *parent = nullptr);
    ~JsonClient();

    bool connectToServer(const QString &host, quint16 port);
    void disconnectFromServer();
    bool isConnected() const;
    bool sendJson(const QJsonObject &json);

signals:
    void jsonReceived(const QJsonObject &json);
    void connected();
    void disconnected();
    void errorOccurred(const QString &errorMessage);

private slots:
    void onConnected();
    void onReadyRead();
    void onDisconnected();
    void onError(QAbstractSocket::SocketError error);
    void onTimeout();

private:
    void processReceiveBuffer();
    bool sendJsonWithLengthPrefix(const QJsonObject &json);

    QTcpSocket *socket;
    QByteArray receiveBuffer;
    quint32 expectedDataSize;
    bool readingSize;
    QTimer *timeoutTimer;
};

#endif // JSONCLIENT_H
```

```cpp
// jsonclient.cpp
#include "jsonclient.h"
#include <QDataStream>
#include <QHostAddress>
#include <QDebug>

JsonClient::JsonClient(QObject *parent)
    : QObject(parent)
    , socket(new QTcpSocket(this))
    , expectedDataSize(0)
    , readingSize(true)
    , timeoutTimer(new QTimer(this))
{
    // 设置socket连接
    connect(socket, &QTcpSocket::connected, this, &JsonClient::onConnected);
    connect(socket, &QTcpSocket::readyRead, this, &JsonClient::onReadyRead);
    connect(socket, &QTcpSocket::disconnected, this, &JsonClient::onDisconnected);
    connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QTcpSocket::errorOccurred),
            this, &JsonClient::onError);

    // 设置超时定时器
    timeoutTimer->setSingleShot(true);
    connect(timeoutTimer, &QTimer::timeout, this, &JsonClient::onTimeout);
}

JsonClient::~JsonClient()
{
    disconnectFromServer();
}

bool JsonClient::connectToServer(const QString &host, quint16 port)
{
    if (socket->state() == QTcpSocket::ConnectedState) {
        disconnectFromServer();
    }

    receiveBuffer.clear();
    expectedDataSize = 0;
    readingSize = true;

    qDebug() << "Connecting to" << host << ":" << port;
    socket->connectToHost(host, port);

    // 设置连接超时
    timeoutTimer->start(5000); // 5秒连接超时

    return socket->waitForConnected(5000);
}

void JsonClient::disconnectFromServer()
{
    if (socket->state() != QTcpSocket::UnconnectedState) {
        socket->disconnectFromHost();
        if (socket->state() != QTcpSocket::UnconnectedState) {
            socket->waitForDisconnected(1000);
        }
    }
}

bool JsonClient::isConnected() const
{
    return socket->state() == QTcpSocket::ConnectedState;
}

bool JsonClient::sendJson(const QJsonObject &json)
{
    if (!isConnected()) {
        emit errorOccurred("Not connected to server");
        return false;
    }

    return sendJsonWithLengthPrefix(json);
}

void JsonClient::onConnected()
{
    timeoutTimer->stop();
    qDebug() << "Connected to server successfully";
    emit connected();
}

void JsonClient::onReadyRead()
{
    // 读取所有可用数据到缓冲区
    receiveBuffer.append(socket->readAll());
    
    // 处理接收缓冲区
    processReceiveBuffer();
}

void JsonClient::processReceiveBuffer()
{
    while (!receiveBuffer.isEmpty()) {
        if (readingSize) {
            // 第一阶段：读取4字节的长度前缀
            if (receiveBuffer.size() < static_cast<int>(sizeof(quint32))) {
                // 数据不足，等待更多数据
                qDebug() << "Waiting for more data to read size prefix...";
                break;
            }

            // 从缓冲区读取长度前缀
            QDataStream sizeStream(receiveBuffer);
            sizeStream.setVersion(QDataStream::Qt_5_15);
            sizeStream >> expectedDataSize;

            // 移除已读取的长度前缀
            receiveBuffer.remove(0, sizeof(quint32));

            qDebug() << "Expecting JSON data of size:" << expectedDataSize << "bytes";

            if (expectedDataSize == 0) {
                // 空数据包，继续读取下一个长度前缀
                qWarning() << "Received zero-length data packet";
                readingSize = true;
                continue;
            }

            if (expectedDataSize > 10 * 1024 * 1024) { // 10MB限制
                qCritical() << "Data size too large:" << expectedDataSize << "bytes";
                disconnectFromServer();
                emit errorOccurred("Data size too large");
                return;
            }

            readingSize = false;
        }

        if (!readingSize) {
            // 第二阶段：读取JSON数据
            if (receiveBuffer.size() < expectedDataSize) {
                // 数据不完整，等待更多数据
                qDebug() << "Waiting for more JSON data..." 
                         << receiveBuffer.size() << "of" << expectedDataSize << "bytes received";
                break;
            }

            // 提取完整的JSON数据
            QByteArray jsonData = receiveBuffer.left(expectedDataSize);
            receiveBuffer.remove(0, expectedDataSize);

            // 解析JSON
            QJsonParseError error;
            QJsonDocument doc = QJsonDocument::fromJson(jsonData, &error);

            if (error.error != QJsonParseError::NoError) {
                qWarning() << "JSON parse error:" << error.errorString();
                emit errorOccurred("JSON parse error: " + error.errorString());
            } else {
                qDebug() << "Successfully received and parsed JSON document";
                emit jsonReceived(doc.object());
            }

            // 重置状态，准备读取下一个数据包
            expectedDataSize = 0;
            readingSize = true;
        }
    }
}

void JsonClient::onDisconnected()
{
    qDebug() << "Disconnected from server";
    receiveBuffer.clear();
    expectedDataSize = 0;
    readingSize = true;
    emit disconnected();
}

void JsonClient::onError(QAbstractSocket::SocketError error)
{
    Q_UNUSED(error);
    QString errorMsg = socket->errorString();
    qWarning() << "Socket error:" << errorMsg;
    emit errorOccurred(errorMsg);
}

void JsonClient::onTimeout()
{
    if (socket->state() == QTcpSocket::ConnectingState) {
        qWarning() << "Connection timeout";
        socket->abort();
        emit errorOccurred("Connection timeout");
    }
}

bool JsonClient::sendJsonWithLengthPrefix(const QJsonObject &json)
{
    QJsonDocument doc(json);
    QByteArray jsonData = doc.toJson(QJsonDocument::Compact);

    // 创建带长度前缀的数据包
    QByteArray packet;
    QDataStream stream(&packet, QIODevice::WriteOnly);
    stream.setVersion(QDataStream::Qt_5_15);
    stream << static_cast<quint32>(jsonData.size());
    packet.append(jsonData);

    // 发送数据
    qint64 bytesWritten = socket->write(packet);
    if (bytesWritten == -1) {
        emit errorOccurred("Write error: " + socket->errorString());
        return false;
    }

    if (bytesWritten != packet.size()) {
        emit errorOccurred(QString("Partial write: %1 of %2 bytes")
                          .arg(bytesWritten).arg(packet.size()));
        return false;
    }

    if (!socket->waitForBytesWritten(3000)) {
        emit errorOccurred("Write timeout");
        return false;
    }

    qDebug() << "Sent JSON data, size:" << jsonData.size() << "bytes";
    return true;
}
```

## 使用示例

```cpp
// main.cpp
#include "jsonclient.h"
#include <QCoreApplication>
#include <QCommandLineParser>
#include <iostream>

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    
    JsonClient client;
    
    // 连接信号
    QObject::connect(&client, &JsonClient::jsonReceived, [](const QJsonObject &json) {
        std::cout << "=== Received JSON ===" << std::endl;
        std::cout << QJsonDocument(json).toJson(QJsonDocument::Indented).toStdString();
        std::cout << "=====================" << std::endl;
    });
    
    QObject::connect(&client, &JsonClient::connected, []() {
        std::cout << "Connected to server!" << std::endl;
    });
    
    QObject::connect(&client, &JsonClient::disconnected, []() {
        std::cout << "Disconnected from server." << std::endl;
        QCoreApplication::quit();
    });
    
    QObject::connect(&client, &JsonClient::errorOccurred, [](const QString &error) {
        std::cerr << "Error: " << error.toStdString() << std::endl;
        QCoreApplication::exit(1);
    });
    
    // 连接到服务器
    if (!client.connectToServer("127.0.0.1", 12345)) {
        std::cerr << "Failed to connect to server" << std::endl;
        return 1;
    }
    
    // 发送测试数据
    QJsonObject testData;
    testData["command"] = "request";
    testData["type"] = "test";
    client.sendJson(testData);
    
    return app.exec();
}
```

## 接收过程详解

### 1. **状态管理**
客户端维护两个状态变量：
- `readingSize`: 当前是否正在读取长度前缀
- `expectedDataSize`: 期望的JSON数据大小

### 2. **接收流程**
```
开始 → 读取4字节长度前缀 → 读取N字节JSON数据 → 解析JSON → 回到开始
```

### 3. **缓冲区处理**
```cpp
while (!receiveBuffer.isEmpty()) {
    if (readingSize) {
        // 读取长度前缀
        if (buffer.size() < 4) break; // 等待更多数据
        // 读取4字节长度
        readingSize = false;
    } else {
        // 读取JSON数据
        if (buffer.size() < expectedDataSize) break; // 等待更多数据
        // 提取并解析JSON
        readingSize = true;
    }
}
```

### 4. **错误处理**
- **数据大小验证**: 防止过大的数据包（10MB限制）
- **超时处理**: 连接和写入超时
- **JSON解析错误**: 无效JSON格式处理

## 处理TCP分包的示例

假设服务器发送的数据被TCP分包：
```
[数据包1]: 00 00 00 62 7B 22 63 6F 6D 6D  (前10字节)
[数据包2]: 61 6E 64 22 3A 22 74 65 73 74  (中间10字节)  
[数据包3]: 5F 6D 65 73 73 61 67 65 22 7D  (最后10字节)
```

客户端处理过程：
1. 收到数据包1，缓冲区有10字节，但需要4字节长度前缀 → 读取长度0x62(98)
2. 需要98字节JSON数据，但只有6字节 → 等待更多数据
3. 收到数据包2，缓冲区有16字节，仍不足98字节 → 继续等待
4. 收到数据包3，缓冲区有26字节，仍不足98字节 → 继续等待
5. ...直到收到足够98字节数据，然后解析JSON

## 关键特性

1. **完整的状态机**: 清晰区分长度读取和数据读取状态
2. **缓冲区管理**: 正确处理TCP分包和粘包
3. **错误恢复**: 各种错误情况的健壮处理
4. **内存安全**: 防止内存溢出和无限循环
5. **超时控制**: 连接和操作超时处理

这种实现确保了客户端能够可靠地接收和处理带长度前缀的JSON数据，无论TCP如何分包传输。