# 项目概览与MVP范围

**目标**：在 Linux 上完成客户端（Qt）+ 服务器（C++）+ 数据库（MySQL/SQLite）的端到端闭环，覆盖注册/登录、预约、病例、医嘱、聊天、考勤等核心路径，可演示、可测试、可发布。

**建议的最小可行版本（MVP）**：

- 注册/登录（账号+密码，RBAC：患者/医生/管理员）
- 预约管理（挂号、查询、取消）
- 病例只读（医生可新增记录，患者可查看）
- 医嘱开立与查看（不涉及复杂收费流程）
- 医患聊天（单聊）
- 医生考勤（打卡与请假）
- 数据分析页（静态/实时图表 2~3 个指标）

MVP 完成后再扩展住院信息、充值、远程采集等。

------

# 系统架构

**拓扑**（文本示意）

```
[Qt 客户端-患者端]     [Qt 客户端-医生端]
           \             /
            \           /
             [TCP 负载均衡/直连]
                      |
                [应用服务器]
               ┌───────────┐
               │  认证服务 │
               │  预约服务 │
               │  病例服务 │  ← 线程池 + epoll/reactor
               │  医嘱服务 │
               │  聊天服务 │  ← 发布/订阅
               │  考勤服务 │
               └───────────┘
                      |
               [MySQL 主库]
                      |
               [审计日志/归档]
```

**客户端本地缓存**：SQLite（QSqlDatabase）用于离线查看最近数据和持久化登录态（仅存 token，不存明文密码）。

**进程与线程模型**：

- 服务器：`master` 进程 + `N` 个 worker（或单进程多线程），每个 worker：1 个 I/O 线程（epoll）+ `M` 个业务线程（线程池）。
- 客户端：UI 线程 + 网络线程（QThread 承载 QTcpSocket）+ 若干后台任务线程（解析、持久化）。

------

# 技术选型

- C++17（gcc ≥ 9，若受限 Ubuntu 老版本，至少确保支持 -std=c++17）
- 网络：Linux 原生 TCP/epoll；客户端可用 Qt 的 QTcpSocket/QSslSocket 封装
- 序列化：JSON（nlohmann/json）作为起步；后续可切换 protobuf
- 数据库：MySQL 8.x（服务端） + SQLite 3（客户端缓存）
- 构建：CMake ≥ 3.16（服务端）；客户端可用 QtCreator 5.12 项目模板
- 测试：GoogleTest + CTest；集成测试用 Python 脚本发 TCP 报文
- 安全：OpenSSL TLS；bcrypt/scrypt/argon2 口令哈希；RBAC + 审计日志

------

# 目录结构建议（单仓库）

```
smart-med/
  server/
    CMakeLists.txt
    src/
      main.cpp
      net/        # epoll、acceptor、connection、codec
      auth/
      appt/
      record/
      order/
      chat/
      attend/
      common/     # 配置、日志、utils、json、error codes
      dao/        # MySQL 访问层（连接池、DAO 对象）
      proto/      # 消息结构（JSON schema / protobuf）
      test/
  client-qt/
    SmartMed.pro  # 或 CMakeLists.txt
    src/
      main.cpp
      ui/         # 界面、QMainWindow、Dialog、Model/View
      net/        # QThread + QTcpSocket 封装，重连、心跳
      models/     # QAbstractTableModel
      cache/      # SQLite 读写
      pages/      # 登录、预约、病例、医嘱、聊天、考勤、图表
  scripts/
    db/
      schema.sql
      seed.sql
    tools/
      tcp_client.py  # 集成测试脚本
  docs/
    api.md
    arch.md
```

------

# 数据库设计（MySQL）

> 推荐使用sqlite，
>
> ORM：对象关系模型

**编码与存储**：`utf8mb4`，`InnoDB`，所有外键列建索引，时间统一 `TIMESTAMP`/`DATETIME`，逻辑删除用 `is_deleted`。

**核心表 DDL 片段**（可直接运行，示例约简）：

```sql
CREATE TABLE users (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  role ENUM('patient','doctor','admin') NOT NULL,
  phone VARCHAR(32) UNIQUE,
  email VARCHAR(128) UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  salt VARBINARY(32) NOT NULL,
  status TINYINT NOT NULL DEFAULT 1,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE patients (
  user_id BIGINT PRIMARY KEY,
  name VARCHAR(64) NOT NULL,
  gender TINYINT,          -- 0未知/1男/2女
  dob DATE,
  id_card VARCHAR(32),
  insurance_no VARCHAR(64),
  allergies TEXT,
  contact VARCHAR(64),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE doctors (
  user_id BIGINT PRIMARY KEY,
  name VARCHAR(64) NOT NULL,
  title VARCHAR(64),
  dept VARCHAR(64),
  license_no VARCHAR(64),
  schedule_json JSON,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE appointments (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  patient_id BIGINT NOT NULL,
  doctor_id BIGINT NOT NULL,
  start_time DATETIME NOT NULL,
  end_time DATETIME NOT NULL,
  status ENUM('booked','cancelled','finished','no_show') NOT NULL DEFAULT 'booked',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_pd_time(patient_id, doctor_id, start_time),
  FOREIGN KEY (patient_id) REFERENCES patients(user_id),
  FOREIGN KEY (doctor_id) REFERENCES doctors(user_id)
);

CREATE TABLE medical_records (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  patient_id BIGINT NOT NULL,
  doctor_id BIGINT NOT NULL,
  visit_time DATETIME NOT NULL,
  diagnosis TEXT,
  prescription TEXT,
  notes TEXT,
  attachments JSON,
  FOREIGN KEY (patient_id) REFERENCES patients(user_id),
  FOREIGN KEY (doctor_id) REFERENCES doctors(user_id)
);

CREATE TABLE orders (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  patient_id BIGINT NOT NULL,
  doctor_id BIGINT NOT NULL,
  type ENUM('lab','drug','procedure') NOT NULL,
  content JSON NOT NULL,
  status ENUM('new','in_progress','done','cancelled') NOT NULL DEFAULT 'new',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE attendance (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  doctor_id BIGINT NOT NULL,
  date DATE NOT NULL,
  checkin DATETIME,
  checkout DATETIME,
  leave_type ENUM('none','sick','annual','other') NOT NULL DEFAULT 'none',
  leave_reason VARCHAR(255),
  UNIQUE KEY uk_doc_date(doctor_id, date),
  FOREIGN KEY (doctor_id) REFERENCES doctors(user_id)
);

CREATE TABLE messages (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  conversation_id BIGINT NOT NULL,
  from_user BIGINT NOT NULL,
  to_user BIGINT NOT NULL,
  sent_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  body TEXT NOT NULL,
  INDEX idx_conv_time(conversation_id, sent_at)
);

CREATE TABLE questionnaires (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  title VARCHAR(128) NOT NULL,
  schema_json JSON NOT NULL
);

CREATE TABLE health_assessments (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  patient_id BIGINT NOT NULL,
  questionnaire_id BIGINT NOT NULL,
  answers_json JSON NOT NULL,
  score INT,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

**SQLite 客户端缓存**：`recent_records`, `recent_messages`, `me` 配置表。

------

# 关键业务流程（时序概览）

**预约**

```
患者 -> 客户端: 选择医生+时间
客户端 -> 服务器: CreateAppointment(req)
服务器 -> 数据库: 悲观/乐观锁校验时段占用
服务器 -> 客户端: 成功/失败
```

**医患聊天**

```
客户端 -> 服务器: Login(token)
客户端 <-> 服务器: Heartbeat
客户端 -> 服务器: SendMessage(conv_id, text)
服务器 -> 订阅者: Fanout(doctor_id/patient_id)
```

**医生考勤**

```
医生客户端 -> 服务器: CheckIn/CheckOut
服务器 -> DB: upsert by (doctor_id, date)
```

------

# 通信协议设计（基于 TCP 长度前缀 + JSON）

**帧格式**

```
| 4 bytes length (big-endian) | JSON payload bytes |
```

**通用报文**

```json
{
  "type": "login",
  "seq": 1001,
  "token": "...",
  "payload": {"phone": "...", "password": "..."}
}
```

**响应**

```json
{ "ok": true, "seq": 1001, "payload": {"user_id": 123, "role": "doctor", "token": "..."} }
```

**消息类型建议**

- `register`, `login`, `logout`, `heartbeat`
- `appt.create`, `appt.list`, `appt.cancel`
- `record.add`, `record.get`
- `order.create`, `order.update`, `order.list`
- `chat.send`, `chat.history`, `chat.ack`
- `attend.checkin`, `attend.checkout`, `attend.leave`

**安全**

- TLS（QSslSocket / OpenSSL）或至少在校内环境中启用 token + HMAC（`timestamp + nonce + HMAC-SHA256`）
- 口令哈希：argon2/bcrypt + per-user salt
- RBAC：按 `role` 与资源拥有者校验访问

------

# 服务器端脚手架（CMake + 示例）

**CMakeLists.txt**（简化）

```cmake
cmake_minimum_required(VERSION 3.16)
project(smart_med_server LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 17)
add_compile_options(-O2 -g -Wall -Wextra -Wpedantic)
find_package(Threads REQUIRED)
add_executable(server
  src/main.cpp
  src/net/epoll_loop.cpp
  src/net/connection.cpp
  src/common/json.cpp
  src/auth/service.cpp
  # ...
)
target_link_libraries(server PRIVATE Threads::Threads ssl crypto mysqlclient)
```

**main.cpp**（示例骨架）

```cpp
int main(int argc, char** argv) {
  Config cfg = Config::Load("server.yml");
  Logger::Init(cfg.log);
  MySQLPool db(cfg.mysql);

  Reactor reactor(cfg.net);
  ThreadPool workers(cfg.workers);

  AuthService auth(db);
  ApptService appt(db);
  ChatService chat(db, reactor.pubsub());

  TcpServer svr(cfg.net, reactor, [&](ConnPtr c){
    c->onMessage([&](ConnPtr c, Buffer& buf){
      for(;;){
        auto msg = Codec::Decode(buf);
        if(!msg) break;
        Dispatcher::Route(*msg, {auth, appt, chat, /*...*/}, c);
      }
    });
  });

  svr.start();
  reactor.loop();
  return 0;
}
```

------

# 客户端 Qt 脚手架

**工程要点**

- UI：`QMainWindow` + `QStackedWidget` 切页；表格用 `QTableView + QAbstractTableModel`
- 网络：`NetworkWorker : public QThread` 内部持有 `QTcpSocket`（或 `QSslSocket`），信号/槽与 UI 解耦
- 序列化：统一 `Message` 封装，提供 `send(type, payload)`
- 缓存：`QSqlDatabase` 写入 SQLite，支持离线只读

**NetworkWorker 片段**

```cpp
class NetworkWorker : public QThread {
  Q_OBJECT
public:
  void run() override {
    QTcpSocket sock;
    sock.connectToHost(host, port);
    connect(&sock, &QTcpSocket::readyRead, [&](){
      buffer.append(sock.readAll());
      while(auto msg = tryDecode(buffer)) emit messageArrived(*msg);
    });
    exec(); // 事件循环
  }
public slots:
  void sendMessage(const QJsonObject& obj){
    QByteArray body = QJsonDocument(obj).toJson(QJsonDocument::Compact);
    QByteArray frame;
    QDataStream ds(&frame, QIODevice::WriteOnly);
    ds.setByteOrder(QDataStream::BigEndian);
    ds << quint32(body.size());
    frame.append(body);
    sock->write(frame);
  }
signals:
  void messageArrived(const QJsonObject& obj);
};
```

------

# 并发与一致性要点

- 预约冲突：基于 `(doctor_id, start_time)` 唯一约束；服务端事务内二次校验
- 聊天送达：服务端 `ack` 与离线消息补发；客户端本地 `pending` 队列重试
- 数据库连接池：上限控制 + 慢查询日志
- 线程安全：DAO/Service 无共享可变状态；跨线程通过队列传递

------

# 测试与质量保障

- 单元测试：Service/DAO 覆盖关键分支（gtest）
- 集成测试：`scripts/tools/tcp_client.py` 发送协议帧验证端到端
- UI 测试：Qt Test 简单冒烟 + 人工脚本
- 静态检查：`clang-tidy`、`cppcheck`、`include-what-you-use`
- 内存/并发：`valgrind`、`asan/ubsan`、`tsan`（竞态排查）

------

# 调试与运维

- gdb：`handle SIGPIPE nostop noprint`；`thread apply all bt`；`catch throw`
- 日志分级：`TRACE/DEBUG/INFO/WARN/ERROR`，按会话 `trace_id` 贯穿
- 配置：`server.yml`（端口、TLS 证书、DB、线程数、限流）
- 部署：`systemd` 服务；或 Docker（如允许）

------

# UI 设计要点（Qt 5.12）

- 全局导航：登录 -> 主页（预约/病例/聊天/考勤/数据）
- 表格：`QTableView` + 右键菜单（查看/编辑）
- 表单：`QFormLayout`；输入校验 `QValidator`
- 图表：可用 `QtCharts` 或在服务端生成统计数据，客户端渲染

------

# 加分功能建议

- 医生排班可视化（拖拽调班）
- 聊天内图片/报告附件上传（分片 + 断点续传）
- 数据分析仪表盘：预约转化率、爽约率、就诊时长箱线图
- 告警/通知：预约变更、医嘱完成回执（系统内 + 邮件/短信网关）

------

# 风险清单与防坑

- 老旧 Ubuntu 版本的编译链限制：建议使用 20.04+；若必须低版本，锁定依赖最小集
- 明文口令、无 TLS：即使校内项目也要禁止；至少 Hash+Salt + Token 轮换
- 数据库外键/索引缺失导致性能/一致性问题：DDL 阶段一次到位
- UI/网络同线程导致卡顿：网络放到 QThread，UI 仅处理信号
- 协议兼容性：为消息定义 `version` 字段，灰度升级

------

# 开发里程碑（四周样例）

- 第 1 周：需求细化与原型、数据库 schema、协议草案、服务器骨架
- 第 2 周：认证/预约/考勤落地，客户端页面联调
- 第 3 周：病例/医嘱/聊天，稳定性与缓存，基础图表
- 第 4 周：测试与优化、安全加固、打包发布、答辩演示

------

# 快速开始

**初始化数据库**

```bash
mysql -u root -p < scripts/db/schema.sql
```

**编译服务器**

```bash
cd server && cmake -S . -B build && cmake --build build -j
./build/server -c ../configs/server.yml
```

**运行客户端（QtCreator）**

- 打开 `client-qt/SmartMed.pro`，配置 Kit，构建并运行

------

# 下一步可交付物清单

- `schema.sql` 与 `seed.sql`（最小种子数据）
- `api.md`（消息类型/字段/错误码）
- 服务器与客户端的最小可运行 Demo（登录、预约创建、聊天收发）
- 集成测试脚本与报告